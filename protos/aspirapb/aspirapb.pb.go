// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aspirapb.proto

package aspirapb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EntryMeta_Type int32

const (
	EntryMeta_Put           EntryMeta_Type = 0
	EntryMeta_LeaderCommit  EntryMeta_Type = 1
	EntryMeta_ConfChange    EntryMeta_Type = 2
	EntryMeta_PutWithOffset EntryMeta_Type = 3
)

var EntryMeta_Type_name = map[int32]string{
	0: "Put",
	1: "LeaderCommit",
	2: "ConfChange",
	3: "PutWithOffset",
}

var EntryMeta_Type_value = map[string]int32{
	"Put":           0,
	"LeaderCommit":  1,
	"ConfChange":    2,
	"PutWithOffset": 3,
}

func (x EntryMeta_Type) String() string {
	return proto.EnumName(EntryMeta_Type_name, int32(x))
}

func (EntryMeta_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5, 0}
}

type AspiraProposal_Type int32

const (
	AspiraProposal_Put           AspiraProposal_Type = 0
	AspiraProposal_PutWithOffset AspiraProposal_Type = 1
	AspiraProposal_Delete        AspiraProposal_Type = 2
)

var AspiraProposal_Type_name = map[int32]string{
	0: "Put",
	1: "PutWithOffset",
	2: "Delete",
}

var AspiraProposal_Type_value = map[string]int32{
	"Put":           0,
	"PutWithOffset": 1,
	"Delete":        2,
}

func (x AspiraProposal_Type) String() string {
	return proto.EnumName(AspiraProposal_Type_name, int32(x))
}

func (AspiraProposal_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6, 0}
}

// Worker services.
type Payload struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{0}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RaftContext struct {
	Id                   uint64   `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{1}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

//save MembershipState into
type MembershipState struct {
	Nodes                map[uint64]string `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{2}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetNodes() map[uint64]string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	ReadTs  uint64       `protobuf:"varint,3,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done bool `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	// since_ts stores the ts of the last snapshot to support diff snap updates.
	SinceTs              uint64   `protobuf:"varint,5,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{3}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Snapshot) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type RaftBatch struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{4}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EntryMeta struct {
	Term                 uint64         `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64         `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	EntryType            EntryMeta_Type `protobuf:"varint,3,opt,name=EntryType,proto3,enum=aspirapb.EntryMeta_Type" json:"EntryType,omitempty"`
	Data                 []byte         `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	AssociateKey         string         `protobuf:"bytes,5,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EntryMeta) Reset()         { *m = EntryMeta{} }
func (m *EntryMeta) String() string { return proto.CompactTextString(m) }
func (*EntryMeta) ProtoMessage()    {}
func (*EntryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5}
}
func (m *EntryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryMeta.Merge(m, src)
}
func (m *EntryMeta) XXX_Size() int {
	return m.Size()
}
func (m *EntryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_EntryMeta proto.InternalMessageInfo

func (m *EntryMeta) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *EntryMeta) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *EntryMeta) GetEntryType() EntryMeta_Type {
	if m != nil {
		return m.EntryType
	}
	return EntryMeta_Put
}

func (m *EntryMeta) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EntryMeta) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

//
//AspiraProposalPut{
//string associateKey
//bytes data
//}
//AspiraProposalPutWithOffset {
//string associateKey
//bytes data
//uint64 key
//uint32 reservation
//uint32 offset
//}
type AspiraProposal struct {
	ProposalType         AspiraProposal_Type `protobuf:"varint,1,opt,name=ProposalType,proto3,enum=aspirapb.AspiraProposal_Type" json:"ProposalType,omitempty"`
	Key                  uint64              `protobuf:"varint,2,opt,name=key,proto3" json:"key,omitempty"`
	Offset               uint64              `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	AssociateKey         string              `protobuf:"bytes,4,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	Data                 []byte              `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AspiraProposal) Reset()         { *m = AspiraProposal{} }
func (m *AspiraProposal) String() string { return proto.CompactTextString(m) }
func (*AspiraProposal) ProtoMessage()    {}
func (*AspiraProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6}
}
func (m *AspiraProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AspiraProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AspiraProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AspiraProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AspiraProposal.Merge(m, src)
}
func (m *AspiraProposal) XXX_Size() int {
	return m.Size()
}
func (m *AspiraProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AspiraProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AspiraProposal proto.InternalMessageInfo

func (m *AspiraProposal) GetProposalType() AspiraProposal_Type {
	if m != nil {
		return m.ProposalType
	}
	return AspiraProposal_Put
}

func (m *AspiraProposal) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *AspiraProposal) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *AspiraProposal) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

func (m *AspiraProposal) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

//zero service
type AllocIDRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRequest) Reset()         { *m = AllocIDRequest{} }
func (m *AllocIDRequest) String() string { return proto.CompactTextString(m) }
func (*AllocIDRequest) ProtoMessage()    {}
func (*AllocIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{7}
}
func (m *AllocIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRequest.Merge(m, src)
}
func (m *AllocIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRequest proto.InternalMessageInfo

type AllocIDResponse struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDResponse) Reset()         { *m = AllocIDResponse{} }
func (m *AllocIDResponse) String() string { return proto.CompactTextString(m) }
func (*AllocIDResponse) ProtoMessage()    {}
func (*AllocIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{8}
}
func (m *AllocIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDResponse.Merge(m, src)
}
func (m *AllocIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDResponse proto.InternalMessageInfo

func (m *AllocIDResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type LeaderReportRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderReportRequest) Reset()         { *m = LeaderReportRequest{} }
func (m *LeaderReportRequest) String() string { return proto.CompactTextString(m) }
func (*LeaderReportRequest) ProtoMessage()    {}
func (*LeaderReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{9}
}
func (m *LeaderReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderReportRequest.Merge(m, src)
}
func (m *LeaderReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaderReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderReportRequest proto.InternalMessageInfo

type LeaderReportReponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderReportReponse) Reset()         { *m = LeaderReportReponse{} }
func (m *LeaderReportReponse) String() string { return proto.CompactTextString(m) }
func (*LeaderReportReponse) ProtoMessage()    {}
func (*LeaderReportReponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{10}
}
func (m *LeaderReportReponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderReportReponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderReportReponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderReportReponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderReportReponse.Merge(m, src)
}
func (m *LeaderReportReponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaderReportReponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderReportReponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderReportReponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("aspirapb.EntryMeta_Type", EntryMeta_Type_name, EntryMeta_Type_value)
	proto.RegisterEnum("aspirapb.AspiraProposal_Type", AspiraProposal_Type_name, AspiraProposal_Type_value)
	proto.RegisterType((*Payload)(nil), "aspirapb.Payload")
	proto.RegisterType((*RaftContext)(nil), "aspirapb.RaftContext")
	proto.RegisterType((*MembershipState)(nil), "aspirapb.MembershipState")
	proto.RegisterMapType((map[uint64]string)(nil), "aspirapb.MembershipState.NodesEntry")
	proto.RegisterType((*Snapshot)(nil), "aspirapb.Snapshot")
	proto.RegisterType((*RaftBatch)(nil), "aspirapb.RaftBatch")
	proto.RegisterType((*EntryMeta)(nil), "aspirapb.EntryMeta")
	proto.RegisterType((*AspiraProposal)(nil), "aspirapb.AspiraProposal")
	proto.RegisterType((*AllocIDRequest)(nil), "aspirapb.AllocIDRequest")
	proto.RegisterType((*AllocIDResponse)(nil), "aspirapb.AllocIDResponse")
	proto.RegisterType((*LeaderReportRequest)(nil), "aspirapb.LeaderReportRequest")
	proto.RegisterType((*LeaderReportReponse)(nil), "aspirapb.LeaderReportReponse")
}

func init() { proto.RegisterFile("aspirapb.proto", fileDescriptor_978c3dd237f791ac) }

var fileDescriptor_978c3dd237f791ac = []byte{
	// 732 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0x13, 0x49,
	0x10, 0x4e, 0x8f, 0xc7, 0x7f, 0x65, 0xaf, 0x33, 0xe9, 0x6c, 0x76, 0x1d, 0x4b, 0xb1, 0xbc, 0xa3,
	0x3d, 0x58, 0x5a, 0xc9, 0x9b, 0xf5, 0x0a, 0x14, 0x72, 0x40, 0x24, 0x36, 0x02, 0x43, 0x02, 0x56,
	0xc7, 0x12, 0x12, 0x17, 0xd4, 0xf6, 0x94, 0xe3, 0x11, 0xf6, 0xf4, 0x30, 0xdd, 0x46, 0xf1, 0x13,
	0xf0, 0x0a, 0x70, 0xe1, 0x25, 0x78, 0x09, 0x8e, 0x3c, 0x02, 0x0a, 0xe2, 0xc4, 0x4b, 0xa0, 0xe9,
	0xf1, 0x78, 0xec, 0xd8, 0x1c, 0x72, 0xab, 0xaa, 0xae, 0xaf, 0xba, 0xbe, 0xaa, 0xaf, 0x1b, 0x4a,
	0x5c, 0xfa, 0x6e, 0xc0, 0xfd, 0x7e, 0xc3, 0x0f, 0x84, 0x12, 0x34, 0x17, 0xfb, 0xf6, 0x01, 0x64,
	0xbb, 0x7c, 0x36, 0x16, 0xdc, 0xa1, 0x14, 0xcc, 0x36, 0x57, 0xbc, 0x4c, 0x6a, 0xa4, 0x5e, 0x64,
	0xda, 0xb6, 0xff, 0x83, 0x02, 0xe3, 0x43, 0xd5, 0x12, 0x9e, 0xc2, 0x2b, 0x45, 0x4b, 0x60, 0xb8,
	0x8e, 0x4e, 0xc8, 0x30, 0xc3, 0xd5, 0x10, 0xee, 0x38, 0x41, 0xd9, 0xa8, 0x91, 0x7a, 0x9e, 0x69,
	0xdb, 0x7e, 0x47, 0x60, 0xfb, 0x1c, 0x27, 0x7d, 0x0c, 0xe4, 0xc8, 0xf5, 0x2f, 0x14, 0x57, 0x48,
	0x8f, 0x21, 0xed, 0x09, 0x07, 0x65, 0x99, 0xd4, 0x52, 0xf5, 0x42, 0xf3, 0xef, 0xc6, 0xa2, 0x9f,
	0x1b, 0x99, 0x8d, 0x67, 0x61, 0xda, 0x43, 0x4f, 0x05, 0x33, 0x16, 0x41, 0x2a, 0x47, 0x00, 0x49,
	0x90, 0x5a, 0x90, 0x7a, 0x8d, 0x33, 0xdd, 0x82, 0xc9, 0x42, 0x93, 0xfe, 0x0e, 0xe9, 0xb7, 0x7c,
	0x3c, 0xc5, 0x79, 0x13, 0x91, 0x73, 0x6c, 0x1c, 0x11, 0xfb, 0x03, 0x81, 0xdc, 0x85, 0xc7, 0x7d,
	0x39, 0x12, 0x8a, 0xfe, 0x0b, 0xd9, 0x41, 0xc4, 0x42, 0x83, 0x0b, 0xcd, 0xbd, 0xa4, 0x89, 0x25,
	0x8a, 0x2c, 0xce, 0x0a, 0xeb, 0xba, 0x9e, 0x83, 0x57, 0xba, 0xae, 0xc9, 0x22, 0x87, 0xfe, 0x09,
	0xd9, 0x00, 0xb9, 0xf3, 0x4a, 0xc9, 0x72, 0x4a, 0xc7, 0x33, 0xa1, 0xdb, 0x93, 0xe1, 0x28, 0x1c,
	0xe1, 0x61, 0xd9, 0xac, 0x91, 0x7a, 0x8e, 0x69, 0x9b, 0xee, 0x43, 0x4e, 0xba, 0xde, 0x00, 0xc3,
	0xec, 0xb4, 0xce, 0xce, 0x6a, 0xbf, 0x27, 0x6d, 0x17, 0xf2, 0xe1, 0xad, 0xa7, 0x5c, 0x0d, 0x46,
	0xb7, 0xef, 0xed, 0x1f, 0xc8, 0xfa, 0xd1, 0xd6, 0x74, 0x77, 0x85, 0xe6, 0x4e, 0x02, 0x98, 0xaf,
	0x93, 0xc5, 0x19, 0xf6, 0x0f, 0x02, 0x79, 0x3d, 0xbc, 0x73, 0x54, 0x3c, 0xec, 0xb3, 0x87, 0xc1,
	0x64, 0x3e, 0x41, 0x6d, 0x87, 0x54, 0x3b, 0xcb, 0x54, 0xb5, 0x43, 0xef, 0xce, 0x61, 0xbd, 0x99,
	0x8f, 0x9a, 0x6c, 0xa9, 0x59, 0x4e, 0xae, 0x59, 0x54, 0x6c, 0x84, 0xe7, 0x2c, 0x49, 0x5d, 0xe8,
	0xc8, 0x4c, 0x74, 0x44, 0x6d, 0x28, 0x72, 0x29, 0xc5, 0xc0, 0xe5, 0x0a, 0x9f, 0xe2, 0x4c, 0x4f,
	0x23, 0xcf, 0x56, 0x62, 0x76, 0x1b, 0x4c, 0x8d, 0xcf, 0x42, 0xaa, 0x3b, 0x55, 0xd6, 0x16, 0xb5,
	0xa0, 0x78, 0x86, 0xdc, 0xc1, 0xa0, 0x25, 0x26, 0x13, 0x57, 0x59, 0x84, 0x96, 0x00, 0x5a, 0xc2,
	0x1b, 0xb6, 0x46, 0xdc, 0xbb, 0x44, 0xcb, 0xa0, 0x3b, 0xf0, 0x5b, 0x77, 0xaa, 0x5e, 0xb8, 0x6a,
	0xf4, 0x7c, 0x38, 0x94, 0xa8, 0xac, 0x94, 0xfd, 0x9d, 0x40, 0xe9, 0x44, 0x37, 0xd9, 0x0d, 0x84,
	0x2f, 0x24, 0x1f, 0xd3, 0x13, 0x28, 0xc6, 0xb6, 0xe6, 0x42, 0x34, 0x97, 0x83, 0x84, 0xcb, 0x6a,
	0x7e, 0x44, 0x68, 0x05, 0x12, 0xcb, 0xce, 0x48, 0x64, 0xf7, 0x07, 0x64, 0x84, 0xbe, 0x33, 0xd6,
	0x41, 0xe4, 0xad, 0x31, 0x35, 0xd7, 0x99, 0x6a, 0xad, 0x84, 0x13, 0x4a, 0x47, 0x13, 0x0a, 0x6d,
	0xbb, 0x71, 0x93, 0xfd, 0x1a, 0x37, 0x42, 0x01, 0x32, 0x6d, 0x1c, 0xa3, 0x42, 0xcb, 0xb0, 0x2d,
	0x28, 0x9d, 0x8c, 0xc7, 0x62, 0xd0, 0x69, 0x33, 0x7c, 0x33, 0x45, 0xa9, 0xec, 0xbf, 0x60, 0x7b,
	0x11, 0x91, 0xbe, 0xf0, 0x24, 0x86, 0xef, 0xb5, 0xd3, 0x9e, 0xaf, 0xda, 0xe8, 0xb4, 0xed, 0x3d,
	0xd8, 0x8d, 0x26, 0xca, 0xd0, 0x17, 0x81, 0x8a, 0x91, 0x6b, 0x61, 0x8d, 0x6e, 0x7e, 0x22, 0x60,
	0x86, 0xf2, 0xa3, 0x77, 0x20, 0xff, 0x18, 0x79, 0xa0, 0xfa, 0xc8, 0x15, 0x5d, 0x97, 0x5a, 0x65,
	0x3d, 0x64, 0x6f, 0x1d, 0x12, 0x7a, 0x2f, 0xfa, 0x3c, 0xce, 0x51, 0x4a, 0x7e, 0x89, 0x74, 0x77,
	0x55, 0xd4, 0x5a, 0xfa, 0x1b, 0xa1, 0x75, 0x0d, 0x7d, 0x22, 0x5c, 0xaf, 0x35, 0x9e, 0x4a, 0x85,
	0x01, 0xdd, 0xfc, 0x1e, 0x36, 0x82, 0x9b, 0x67, 0x00, 0xd1, 0x3e, 0x1f, 0xb1, 0x6e, 0x8b, 0xde,
	0x87, 0xd2, 0x85, 0x0a, 0x90, 0x4f, 0x16, 0x1f, 0xc1, 0x2d, 0x6a, 0x1d, 0x92, 0xe6, 0x47, 0x02,
	0xb9, 0x97, 0x18, 0x08, 0x5d, 0xac, 0x1b, 0x0b, 0x32, 0x9a, 0x13, 0x5d, 0x92, 0xd0, 0x86, 0xb1,
	0x56, 0x7e, 0x79, 0xac, 0xc7, 0xab, 0x79, 0x3e, 0x80, 0xec, 0x7c, 0x67, 0x74, 0xe9, 0x6d, 0xad,
	0x2e, 0xb6, 0xb2, 0xbf, 0xe1, 0x44, 0xce, 0x6b, 0x9c, 0x5a, 0x9f, 0xaf, 0xab, 0xe4, 0xcb, 0x75,
	0x95, 0x7c, 0xbd, 0xae, 0x92, 0xf7, 0xdf, 0xaa, 0x5b, 0xfd, 0x8c, 0xfe, 0xe3, 0xff, 0xff, 0x19,
	0x00, 0x00, 0xff, 0xff, 0x32, 0x79, 0xdc, 0xbe, 0xf5, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/aspirapb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[1], "/aspirapb.Raft/RaftMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/aspirapb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	JoinCluster(context.Context, *RaftContext) (*Payload, error)
}

// UnimplementedRaftServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (*UnimplementedRaftServer) Heartbeat(req *Payload, srv Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (*UnimplementedRaftServer) RaftMessage(srv Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (*UnimplementedRaftServer) JoinCluster(ctx context.Context, req *RaftContext) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// AspiraGRPCClient is the client API for AspiraGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AspiraGRPCClient interface {
	StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (AspiraGRPC_StreamSnapshotClient, error)
}

type aspiraGRPCClient struct {
	cc *grpc.ClientConn
}

func NewAspiraGRPCClient(cc *grpc.ClientConn) AspiraGRPCClient {
	return &aspiraGRPCClient{cc}
}

func (c *aspiraGRPCClient) StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (AspiraGRPC_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AspiraGRPC_serviceDesc.Streams[0], "/aspirapb.AspiraGRPC/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &aspiraGRPCStreamSnapshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AspiraGRPC_StreamSnapshotClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type aspiraGRPCStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *aspiraGRPCStreamSnapshotClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AspiraGRPCServer is the server API for AspiraGRPC service.
type AspiraGRPCServer interface {
	StreamSnapshot(*RaftContext, AspiraGRPC_StreamSnapshotServer) error
}

// UnimplementedAspiraGRPCServer can be embedded to have forward compatible implementations.
type UnimplementedAspiraGRPCServer struct {
}

func (*UnimplementedAspiraGRPCServer) StreamSnapshot(req *RaftContext, srv AspiraGRPC_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}

func RegisterAspiraGRPCServer(s *grpc.Server, srv AspiraGRPCServer) {
	s.RegisterService(&_AspiraGRPC_serviceDesc, srv)
}

func _AspiraGRPC_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RaftContext)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AspiraGRPCServer).StreamSnapshot(m, &aspiraGRPCStreamSnapshotServer{stream})
}

type AspiraGRPC_StreamSnapshotServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type aspiraGRPCStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *aspiraGRPCStreamSnapshotServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

var _AspiraGRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.AspiraGRPC",
	HandlerType: (*AspiraGRPCServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _AspiraGRPC_StreamSnapshot_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// ZeroGRPCClient is the client API for ZeroGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZeroGRPCClient interface {
	LeaderReport(ctx context.Context, opts ...grpc.CallOption) (ZeroGRPC_LeaderReportClient, error)
	AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error)
}

type zeroGRPCClient struct {
	cc *grpc.ClientConn
}

func NewZeroGRPCClient(cc *grpc.ClientConn) ZeroGRPCClient {
	return &zeroGRPCClient{cc}
}

func (c *zeroGRPCClient) LeaderReport(ctx context.Context, opts ...grpc.CallOption) (ZeroGRPC_LeaderReportClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ZeroGRPC_serviceDesc.Streams[0], "/aspirapb.ZeroGRPC/LeaderReport", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroGRPCLeaderReportClient{stream}
	return x, nil
}

type ZeroGRPC_LeaderReportClient interface {
	Send(*LeaderReportRequest) error
	CloseAndRecv() (*LeaderReportReponse, error)
	grpc.ClientStream
}

type zeroGRPCLeaderReportClient struct {
	grpc.ClientStream
}

func (x *zeroGRPCLeaderReportClient) Send(m *LeaderReportRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *zeroGRPCLeaderReportClient) CloseAndRecv() (*LeaderReportReponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(LeaderReportReponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroGRPCClient) AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error) {
	out := new(AllocIDResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.ZeroGRPC/AllocID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroGRPCServer is the server API for ZeroGRPC service.
type ZeroGRPCServer interface {
	LeaderReport(ZeroGRPC_LeaderReportServer) error
	AllocID(context.Context, *AllocIDRequest) (*AllocIDResponse, error)
}

// UnimplementedZeroGRPCServer can be embedded to have forward compatible implementations.
type UnimplementedZeroGRPCServer struct {
}

func (*UnimplementedZeroGRPCServer) LeaderReport(srv ZeroGRPC_LeaderReportServer) error {
	return status.Errorf(codes.Unimplemented, "method LeaderReport not implemented")
}
func (*UnimplementedZeroGRPCServer) AllocID(ctx context.Context, req *AllocIDRequest) (*AllocIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocID not implemented")
}

func RegisterZeroGRPCServer(s *grpc.Server, srv ZeroGRPCServer) {
	s.RegisterService(&_ZeroGRPC_serviceDesc, srv)
}

func _ZeroGRPC_LeaderReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ZeroGRPCServer).LeaderReport(&zeroGRPCLeaderReportServer{stream})
}

type ZeroGRPC_LeaderReportServer interface {
	SendAndClose(*LeaderReportReponse) error
	Recv() (*LeaderReportRequest, error)
	grpc.ServerStream
}

type zeroGRPCLeaderReportServer struct {
	grpc.ServerStream
}

func (x *zeroGRPCLeaderReportServer) SendAndClose(m *LeaderReportReponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *zeroGRPCLeaderReportServer) Recv() (*LeaderReportRequest, error) {
	m := new(LeaderReportRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ZeroGRPC_AllocID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroGRPCServer).AllocID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.ZeroGRPC/AllocID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroGRPCServer).AllocID(ctx, req.(*AllocIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZeroGRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.ZeroGRPC",
	HandlerType: (*ZeroGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllocID",
			Handler:    _ZeroGRPC_AllocID_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LeaderReport",
			Handler:       _ZeroGRPC_LeaderReport_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MembershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAspirapb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SinceTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReadTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntryMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.EntryType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AspiraProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AspiraProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AspiraProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Offset != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Key != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x10
	}
	if m.ProposalType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ProposalType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeaderReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LeaderReportReponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderReportReponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderReportReponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintAspirapb(dAtA []byte, offset int, v uint64) int {
	offset -= sovAspirapb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + 1 + len(v) + sovAspirapb(uint64(len(v)))
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.ReadTs != 0 {
		n += 1 + sovAspirapb(uint64(m.ReadTs))
	}
	if m.Done {
		n += 2
	}
	if m.SinceTs != 0 {
		n += 1 + sovAspirapb(uint64(m.SinceTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovAspirapb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.EntryType != 0 {
		n += 1 + sovAspirapb(uint64(m.EntryType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AspiraProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalType != 0 {
		n += 1 + sovAspirapb(uint64(m.ProposalType))
	}
	if m.Key != 0 {
		n += 1 + sovAspirapb(uint64(m.Key))
	}
	if m.Offset != 0 {
		n += 1 + sovAspirapb(uint64(m.Offset))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAspirapb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderReportReponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAspirapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAspirapb(x uint64) (n int) {
	return sovAspirapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= EntryMeta_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AspiraProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AspiraProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AspiraProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalType", wireType)
			}
			m.ProposalType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalType |= AspiraProposal_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderReportReponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderReportReponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderReportReponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAspirapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAspirapb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAspirapb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAspirapb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAspirapb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAspirapb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAspirapb = fmt.Errorf("proto: unexpected end of group")
)
