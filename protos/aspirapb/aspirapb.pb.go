// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aspirapb.proto

package aspirapb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EntryMeta_Type int32

const (
	EntryMeta_Put           EntryMeta_Type = 0
	EntryMeta_LeaderCommit  EntryMeta_Type = 1
	EntryMeta_ConfChange    EntryMeta_Type = 2
	EntryMeta_PutWithOffset EntryMeta_Type = 3
)

var EntryMeta_Type_name = map[int32]string{
	0: "Put",
	1: "LeaderCommit",
	2: "ConfChange",
	3: "PutWithOffset",
}

var EntryMeta_Type_value = map[string]int32{
	"Put":           0,
	"LeaderCommit":  1,
	"ConfChange":    2,
	"PutWithOffset": 3,
}

func (x EntryMeta_Type) String() string {
	return proto.EnumName(EntryMeta_Type_name, int32(x))
}

func (EntryMeta_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5, 0}
}

type AspiraProposal_Type int32

const (
	AspiraProposal_Put           AspiraProposal_Type = 0
	AspiraProposal_PutWithOffset AspiraProposal_Type = 1
	AspiraProposal_Delete        AspiraProposal_Type = 2
)

var AspiraProposal_Type_name = map[int32]string{
	0: "Put",
	1: "PutWithOffset",
	2: "Delete",
}

var AspiraProposal_Type_value = map[string]int32{
	"Put":           0,
	"PutWithOffset": 1,
	"Delete":        2,
}

func (x AspiraProposal_Type) String() string {
	return proto.EnumName(AspiraProposal_Type_name, int32(x))
}

func (AspiraProposal_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6, 0}
}

type WorkerHeartbeatRequest_ProgressType int32

const (
	WorkerHeartbeatRequest_Probe     WorkerHeartbeatRequest_ProgressType = 0
	WorkerHeartbeatRequest_Replicate WorkerHeartbeatRequest_ProgressType = 1
	WorkerHeartbeatRequest_Snapshot  WorkerHeartbeatRequest_ProgressType = 2
)

var WorkerHeartbeatRequest_ProgressType_name = map[int32]string{
	0: "Probe",
	1: "Replicate",
	2: "Snapshot",
}

var WorkerHeartbeatRequest_ProgressType_value = map[string]int32{
	"Probe":     0,
	"Replicate": 1,
	"Snapshot":  2,
}

func (x WorkerHeartbeatRequest_ProgressType) String() string {
	return proto.EnumName(WorkerHeartbeatRequest_ProgressType_name, int32(x))
}

func (WorkerHeartbeatRequest_ProgressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{11, 0}
}

// Worker services.
type Payload struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{0}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RaftContext struct {
	Id                   uint64   `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{1}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

//save MembershipState into
type MembershipState struct {
	Nodes                map[uint64]string `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{2}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetNodes() map[uint64]string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	ReadTs  uint64       `protobuf:"varint,3,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done bool `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	// since_ts stores the ts of the last snapshot to support diff snap updates.
	SinceTs              uint64   `protobuf:"varint,5,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{3}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Snapshot) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type RaftBatch struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{4}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EntryMeta struct {
	Term                 uint64         `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64         `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	EntryType            EntryMeta_Type `protobuf:"varint,3,opt,name=EntryType,proto3,enum=aspirapb.EntryMeta_Type" json:"EntryType,omitempty"`
	Data                 []byte         `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	AssociateKey         string         `protobuf:"bytes,5,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EntryMeta) Reset()         { *m = EntryMeta{} }
func (m *EntryMeta) String() string { return proto.CompactTextString(m) }
func (*EntryMeta) ProtoMessage()    {}
func (*EntryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5}
}
func (m *EntryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryMeta.Merge(m, src)
}
func (m *EntryMeta) XXX_Size() int {
	return m.Size()
}
func (m *EntryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_EntryMeta proto.InternalMessageInfo

func (m *EntryMeta) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *EntryMeta) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *EntryMeta) GetEntryType() EntryMeta_Type {
	if m != nil {
		return m.EntryType
	}
	return EntryMeta_Put
}

func (m *EntryMeta) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EntryMeta) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

//
//AspiraProposalPut{
//string associateKey
//bytes data
//}
//AspiraProposalPutWithOffset {
//string associateKey
//bytes data
//uint64 key
//uint32 reservation
//uint32 offset
//}
type AspiraProposal struct {
	ProposalType         AspiraProposal_Type `protobuf:"varint,1,opt,name=ProposalType,proto3,enum=aspirapb.AspiraProposal_Type" json:"ProposalType,omitempty"`
	Key                  uint64              `protobuf:"varint,2,opt,name=key,proto3" json:"key,omitempty"`
	Offset               uint64              `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	AssociateKey         string              `protobuf:"bytes,4,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	Data                 []byte              `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AspiraProposal) Reset()         { *m = AspiraProposal{} }
func (m *AspiraProposal) String() string { return proto.CompactTextString(m) }
func (*AspiraProposal) ProtoMessage()    {}
func (*AspiraProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6}
}
func (m *AspiraProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AspiraProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AspiraProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AspiraProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AspiraProposal.Merge(m, src)
}
func (m *AspiraProposal) XXX_Size() int {
	return m.Size()
}
func (m *AspiraProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AspiraProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AspiraProposal proto.InternalMessageInfo

func (m *AspiraProposal) GetProposalType() AspiraProposal_Type {
	if m != nil {
		return m.ProposalType
	}
	return AspiraProposal_Put
}

func (m *AspiraProposal) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *AspiraProposal) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *AspiraProposal) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

func (m *AspiraProposal) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlobRaftMessageRequest struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BlobRaftMessageRequest) Reset()         { *m = BlobRaftMessageRequest{} }
func (m *BlobRaftMessageRequest) String() string { return proto.CompactTextString(m) }
func (*BlobRaftMessageRequest) ProtoMessage()    {}
func (*BlobRaftMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{7}
}
func (m *BlobRaftMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobRaftMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobRaftMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobRaftMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobRaftMessageRequest.Merge(m, src)
}
func (m *BlobRaftMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobRaftMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobRaftMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobRaftMessageRequest proto.InternalMessageInfo

func (m *BlobRaftMessageRequest) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *BlobRaftMessageRequest) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type BlobRaftMessageResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobRaftMessageResponse) Reset()         { *m = BlobRaftMessageResponse{} }
func (m *BlobRaftMessageResponse) String() string { return proto.CompactTextString(m) }
func (*BlobRaftMessageResponse) ProtoMessage()    {}
func (*BlobRaftMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{8}
}
func (m *BlobRaftMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobRaftMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobRaftMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobRaftMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobRaftMessageResponse.Merge(m, src)
}
func (m *BlobRaftMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobRaftMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobRaftMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobRaftMessageResponse proto.InternalMessageInfo

//zero service
type AllocIDRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRequest) Reset()         { *m = AllocIDRequest{} }
func (m *AllocIDRequest) String() string { return proto.CompactTextString(m) }
func (*AllocIDRequest) ProtoMessage()    {}
func (*AllocIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{9}
}
func (m *AllocIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRequest.Merge(m, src)
}
func (m *AllocIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRequest proto.InternalMessageInfo

type AllocIDResponse struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDResponse) Reset()         { *m = AllocIDResponse{} }
func (m *AllocIDResponse) String() string { return proto.CompactTextString(m) }
func (*AllocIDResponse) ProtoMessage()    {}
func (*AllocIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{10}
}
func (m *AllocIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDResponse.Merge(m, src)
}
func (m *AllocIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDResponse proto.InternalMessageInfo

func (m *AllocIDResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type WorkerHeartbeatRequest struct {
	State                *MembershipState                               `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	Progress             map[uint64]WorkerHeartbeatRequest_ProgressType `protobuf:"bytes,2,rep,name=progress,proto3" json:"progress,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=aspirapb.WorkerHeartbeatRequest_ProgressType"`
	Rd                   *RaftContext                                   `protobuf:"bytes,3,opt,name=rd,proto3" json:"rd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *WorkerHeartbeatRequest) Reset()         { *m = WorkerHeartbeatRequest{} }
func (m *WorkerHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*WorkerHeartbeatRequest) ProtoMessage()    {}
func (*WorkerHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{11}
}
func (m *WorkerHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerHeartbeatRequest.Merge(m, src)
}
func (m *WorkerHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *WorkerHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerHeartbeatRequest proto.InternalMessageInfo

func (m *WorkerHeartbeatRequest) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WorkerHeartbeatRequest) GetProgress() map[uint64]WorkerHeartbeatRequest_ProgressType {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (m *WorkerHeartbeatRequest) GetRd() *RaftContext {
	if m != nil {
		return m.Rd
	}
	return nil
}

type WorkerHeartbeatResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkerHeartbeatResponse) Reset()         { *m = WorkerHeartbeatResponse{} }
func (m *WorkerHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*WorkerHeartbeatResponse) ProtoMessage()    {}
func (*WorkerHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{12}
}
func (m *WorkerHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerHeartbeatResponse.Merge(m, src)
}
func (m *WorkerHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *WorkerHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerHeartbeatResponse proto.InternalMessageInfo

type ZeroStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroStatusRequest) Reset()         { *m = ZeroStatusRequest{} }
func (m *ZeroStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroStatusRequest) ProtoMessage()    {}
func (*ZeroStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{13}
}
func (m *ZeroStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroStatusRequest.Merge(m, src)
}
func (m *ZeroStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroStatusRequest proto.InternalMessageInfo

type ZeroStatusResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroStatusResponse) Reset()         { *m = ZeroStatusResponse{} }
func (m *ZeroStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroStatusResponse) ProtoMessage()    {}
func (*ZeroStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{14}
}
func (m *ZeroStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroStatusResponse.Merge(m, src)
}
func (m *ZeroStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroStatusResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("aspirapb.EntryMeta_Type", EntryMeta_Type_name, EntryMeta_Type_value)
	proto.RegisterEnum("aspirapb.AspiraProposal_Type", AspiraProposal_Type_name, AspiraProposal_Type_value)
	proto.RegisterEnum("aspirapb.WorkerHeartbeatRequest_ProgressType", WorkerHeartbeatRequest_ProgressType_name, WorkerHeartbeatRequest_ProgressType_value)
	proto.RegisterType((*Payload)(nil), "aspirapb.Payload")
	proto.RegisterType((*RaftContext)(nil), "aspirapb.RaftContext")
	proto.RegisterType((*MembershipState)(nil), "aspirapb.MembershipState")
	proto.RegisterMapType((map[uint64]string)(nil), "aspirapb.MembershipState.NodesEntry")
	proto.RegisterType((*Snapshot)(nil), "aspirapb.Snapshot")
	proto.RegisterType((*RaftBatch)(nil), "aspirapb.RaftBatch")
	proto.RegisterType((*EntryMeta)(nil), "aspirapb.EntryMeta")
	proto.RegisterType((*AspiraProposal)(nil), "aspirapb.AspiraProposal")
	proto.RegisterType((*BlobRaftMessageRequest)(nil), "aspirapb.BlobRaftMessageRequest")
	proto.RegisterType((*BlobRaftMessageResponse)(nil), "aspirapb.BlobRaftMessageResponse")
	proto.RegisterType((*AllocIDRequest)(nil), "aspirapb.AllocIDRequest")
	proto.RegisterType((*AllocIDResponse)(nil), "aspirapb.AllocIDResponse")
	proto.RegisterType((*WorkerHeartbeatRequest)(nil), "aspirapb.WorkerHeartbeatRequest")
	proto.RegisterMapType((map[uint64]WorkerHeartbeatRequest_ProgressType)(nil), "aspirapb.WorkerHeartbeatRequest.ProgressEntry")
	proto.RegisterType((*WorkerHeartbeatResponse)(nil), "aspirapb.WorkerHeartbeatResponse")
	proto.RegisterType((*ZeroStatusRequest)(nil), "aspirapb.ZeroStatusRequest")
	proto.RegisterType((*ZeroStatusResponse)(nil), "aspirapb.ZeroStatusResponse")
}

func init() { proto.RegisterFile("aspirapb.proto", fileDescriptor_978c3dd237f791ac) }

var fileDescriptor_978c3dd237f791ac = []byte{
	// 914 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xf7, 0x9e, 0xff, 0x4f, 0x1c, 0xe7, 0xb2, 0x2d, 0xa9, 0x63, 0x68, 0xe4, 0x9e, 0x40, 0xb2,
	0x84, 0x30, 0xc5, 0x88, 0xaa, 0xf4, 0x01, 0x91, 0xd8, 0x08, 0x5c, 0x1a, 0xb0, 0x2e, 0x91, 0x5a,
	0xf1, 0x82, 0xd6, 0xbe, 0x49, 0x7c, 0xf4, 0x7c, 0x7b, 0xec, 0xae, 0xab, 0xfa, 0x13, 0xf0, 0xc4,
	0x3b, 0x7c, 0x23, 0x1e, 0xf9, 0x08, 0x55, 0x10, 0x4f, 0x3c, 0xf1, 0x0d, 0xd0, 0xee, 0x9d, 0xef,
	0xec, 0xf8, 0x82, 0xc8, 0x03, 0x6f, 0x33, 0xbb, 0xbf, 0x99, 0x9d, 0xdf, 0xcc, 0xef, 0xc6, 0x86,
	0x26, 0x93, 0x91, 0x2f, 0x58, 0x34, 0xe9, 0x45, 0x82, 0x2b, 0x4e, 0x6b, 0x2b, 0xdf, 0xb9, 0x0f,
	0xd5, 0x31, 0x5b, 0x06, 0x9c, 0x79, 0x94, 0x42, 0x69, 0xc8, 0x14, 0x6b, 0x91, 0x0e, 0xe9, 0x36,
	0x5c, 0x63, 0x3b, 0x1f, 0xc1, 0x8e, 0xcb, 0x2e, 0xd4, 0x80, 0x87, 0x0a, 0x5f, 0x2b, 0xda, 0x04,
	0xcb, 0xf7, 0x0c, 0xa0, 0xe2, 0x5a, 0xbe, 0x09, 0x61, 0x9e, 0x27, 0x5a, 0x56, 0x87, 0x74, 0xeb,
	0xae, 0xb1, 0x9d, 0x9f, 0x08, 0xec, 0x9d, 0xe2, 0x7c, 0x82, 0x42, 0xce, 0xfc, 0xe8, 0x4c, 0x31,
	0x85, 0xf4, 0x09, 0x94, 0x43, 0xee, 0xa1, 0x6c, 0x91, 0x4e, 0xb1, 0xbb, 0xd3, 0x7f, 0xb7, 0x97,
	0xd6, 0x73, 0x0d, 0xd9, 0xfb, 0x46, 0xc3, 0xbe, 0x08, 0x95, 0x58, 0xba, 0x71, 0x48, 0xfb, 0x31,
	0x40, 0x76, 0x48, 0x6d, 0x28, 0xbe, 0xc4, 0xa5, 0x29, 0xa1, 0xe4, 0x6a, 0x93, 0xde, 0x85, 0xf2,
	0x2b, 0x16, 0x2c, 0x30, 0x29, 0x22, 0x76, 0x9e, 0x58, 0x8f, 0x89, 0xf3, 0x2b, 0x81, 0xda, 0x59,
	0xc8, 0x22, 0x39, 0xe3, 0x8a, 0x7e, 0x08, 0xd5, 0x69, 0xcc, 0xc2, 0x04, 0xef, 0xf4, 0xdf, 0xca,
	0x8a, 0x58, 0xa3, 0xe8, 0xae, 0x50, 0x3a, 0xaf, 0x1f, 0x7a, 0xf8, 0xda, 0xe4, 0x2d, 0xb9, 0xb1,
	0x43, 0xef, 0x41, 0x55, 0x20, 0xf3, 0xbe, 0x57, 0xb2, 0x55, 0x34, 0xe7, 0x15, 0xed, 0x9e, 0x4b,
	0xdd, 0x0a, 0x8f, 0x87, 0xd8, 0x2a, 0x75, 0x48, 0xb7, 0xe6, 0x1a, 0x9b, 0x1e, 0x42, 0x4d, 0xfa,
	0xe1, 0x14, 0x35, 0xba, 0x6c, 0xd0, 0x55, 0xe3, 0x9f, 0x4b, 0xc7, 0x87, 0xba, 0x7e, 0xf5, 0x84,
	0xa9, 0xe9, 0xec, 0xf6, 0xb5, 0xbd, 0x0f, 0xd5, 0x28, 0x9e, 0x9a, 0xa9, 0x6e, 0xa7, 0xbf, 0x9f,
	0x05, 0x24, 0xe3, 0x74, 0x57, 0x08, 0xe7, 0x2f, 0x02, 0x75, 0xd3, 0xbc, 0x53, 0x54, 0x4c, 0xd7,
	0x79, 0x8e, 0x62, 0x9e, 0x74, 0xd0, 0xd8, 0x9a, 0xea, 0x68, 0x9d, 0xaa, 0x71, 0xe8, 0xa3, 0x24,
	0xec, 0x7c, 0x19, 0xa1, 0x21, 0xdb, 0xec, 0xb7, 0xb2, 0x67, 0xd2, 0x8c, 0x3d, 0x7d, 0xef, 0x66,
	0xd0, 0x54, 0x47, 0xa5, 0x4c, 0x47, 0xd4, 0x81, 0x06, 0x93, 0x92, 0x4f, 0x7d, 0xa6, 0xf0, 0x6b,
	0x5c, 0x9a, 0x6e, 0xd4, 0xdd, 0x8d, 0x33, 0x67, 0x08, 0x25, 0x13, 0x5f, 0x85, 0xe2, 0x78, 0xa1,
	0xec, 0x02, 0xb5, 0xa1, 0xf1, 0x0c, 0x99, 0x87, 0x62, 0xc0, 0xe7, 0x73, 0x5f, 0xd9, 0x84, 0x36,
	0x01, 0x06, 0x3c, 0xbc, 0x18, 0xcc, 0x58, 0x78, 0x89, 0xb6, 0x45, 0xf7, 0x61, 0x77, 0xbc, 0x50,
	0xcf, 0x7d, 0x35, 0xfb, 0xf6, 0xe2, 0x42, 0xa2, 0xb2, 0x8b, 0xce, 0x9f, 0x04, 0x9a, 0xc7, 0xa6,
	0xc8, 0xb1, 0xe0, 0x11, 0x97, 0x2c, 0xa0, 0xc7, 0xd0, 0x58, 0xd9, 0x86, 0x0b, 0x31, 0x5c, 0xee,
	0x67, 0x5c, 0x36, 0xf1, 0x31, 0xa1, 0x8d, 0x90, 0x95, 0xec, 0xac, 0x4c, 0x76, 0x07, 0x50, 0xe1,
	0xe6, 0xcd, 0x95, 0x0e, 0x62, 0x6f, 0x8b, 0x69, 0x69, 0x9b, 0xa9, 0xd1, 0x8a, 0xee, 0x50, 0x39,
	0xee, 0x90, 0xb6, 0x9d, 0xde, 0x75, 0xf6, 0x5b, 0xdc, 0x08, 0x05, 0xa8, 0x0c, 0x31, 0x40, 0x85,
	0xb6, 0xe5, 0xbc, 0x82, 0x83, 0x93, 0x80, 0x4f, 0xb4, 0x3c, 0x4e, 0x51, 0x4a, 0x76, 0x89, 0x2e,
	0xfe, 0xb8, 0x40, 0xa9, 0xfe, 0x67, 0x35, 0x1d, 0xc2, 0xbd, 0xad, 0x77, 0x65, 0xc4, 0x43, 0x89,
	0x8e, 0x0d, 0xcd, 0xe3, 0x20, 0xe0, 0xd3, 0xd1, 0x30, 0x29, 0xc5, 0x79, 0x00, 0x7b, 0xe9, 0x49,
	0x0c, 0xd2, 0x2b, 0x64, 0x34, 0x4c, 0xd4, 0x67, 0x8d, 0x86, 0xce, 0x1b, 0x0b, 0x0e, 0x9e, 0x73,
	0xf1, 0x12, 0xc5, 0x57, 0xc8, 0x84, 0x9a, 0x20, 0x53, 0x19, 0x91, 0xb2, 0xd4, 0x4b, 0x21, 0xa1,
	0x71, 0x78, 0xe3, 0xd6, 0x70, 0x63, 0x1c, 0x7d, 0x0a, 0xb5, 0x48, 0xf0, 0x4b, 0x81, 0x52, 0xb6,
	0x2c, 0xb3, 0x69, 0x7a, 0x59, 0x4c, 0xfe, 0x23, 0xbd, 0x71, 0x12, 0x10, 0xef, 0x9c, 0x34, 0x9e,
	0xbe, 0x07, 0x96, 0xf0, 0xcc, 0x6c, 0x6f, 0x6c, 0xa0, 0x25, 0xbc, 0xf6, 0x0f, 0xb0, 0xbb, 0x91,
	0x21, 0x67, 0x41, 0x0d, 0xd6, 0x17, 0x54, 0xb3, 0xff, 0xc1, 0x7f, 0x2e, 0xc9, 0xe8, 0x70, 0x6d,
	0x9f, 0x3d, 0x32, 0x3a, 0x4e, 0xaf, 0x68, 0x1d, 0xca, 0x63, 0xc1, 0x27, 0x68, 0x17, 0xe8, 0x2e,
	0xd4, 0x5d, 0x8c, 0x02, 0x7f, 0xca, 0x14, 0xda, 0x84, 0x36, 0xb2, 0xc5, 0x67, 0x5b, 0x7a, 0x64,
	0x5b, 0x2f, 0x25, 0x23, 0xbb, 0x03, 0xfb, 0xdf, 0xa1, 0xe0, 0xba, 0x8b, 0x0b, 0xb9, 0x9a, 0xda,
	0x5d, 0xa0, 0xeb, 0x87, 0x31, 0xb4, 0xff, 0xb3, 0x05, 0x25, 0xcd, 0x9e, 0x7e, 0x02, 0xf5, 0x34,
	0x11, 0xdd, 0x96, 0x4a, 0x7b, 0xfb, 0xc8, 0x29, 0x3c, 0x24, 0xf4, 0xd3, 0xf8, 0xa7, 0x24, 0x11,
	0x0d, 0xbd, 0xb3, 0xd9, 0x53, 0xb3, 0x08, 0x73, 0x43, 0xbb, 0x84, 0xbe, 0x80, 0xbd, 0x6b, 0x9a,
	0xa3, 0x9d, 0x0c, 0x99, 0xff, 0x19, 0xb4, 0x1f, 0xfc, 0x0b, 0x22, 0x61, 0x5f, 0xd0, 0x45, 0x3d,
	0xe5, 0x7e, 0x38, 0x08, 0x16, 0x52, 0xa1, 0xa0, 0xf9, 0x83, 0xce, 0x2d, 0xab, 0xff, 0x0c, 0x20,
	0xde, 0x1b, 0x5f, 0xba, 0xe3, 0x01, 0xfd, 0x0c, 0x9a, 0x67, 0x4a, 0x20, 0x9b, 0xa7, 0x3f, 0x38,
	0xb7, 0xc8, 0xf5, 0x90, 0xf4, 0xff, 0x26, 0x50, 0xd3, 0x4d, 0x37, 0xc9, 0x5e, 0xc0, 0xde, 0xb5,
	0x81, 0xad, 0xf3, 0xcd, 0x57, 0xcd, 0x3a, 0xdf, 0x9b, 0xa6, 0x5d, 0xa0, 0x9f, 0x43, 0x35, 0xf9,
	0x20, 0xe9, 0xda, 0x2e, 0xdf, 0xfc, 0x6a, 0xdb, 0x87, 0x39, 0x37, 0x69, 0x86, 0x11, 0x40, 0x26,
	0x0e, 0xfa, 0x76, 0x06, 0xdd, 0xd2, 0x51, 0xfb, 0x9d, 0xfc, 0xcb, 0x55, 0xaa, 0x13, 0xfb, 0xb7,
	0xab, 0x23, 0xf2, 0xfb, 0xd5, 0x11, 0x79, 0x73, 0x75, 0x44, 0x7e, 0xf9, 0xe3, 0xa8, 0x30, 0xa9,
	0x98, 0xbf, 0x27, 0x1f, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x88, 0x5a, 0x02, 0x74, 0xb0, 0x08,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	BlobRaftMessage(ctx context.Context, in *BlobRaftMessageRequest, opts ...grpc.CallOption) (*BlobRaftMessageResponse, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/aspirapb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[1], "/aspirapb.Raft/RaftMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) BlobRaftMessage(ctx context.Context, in *BlobRaftMessageRequest, opts ...grpc.CallOption) (*BlobRaftMessageResponse, error) {
	out := new(BlobRaftMessageResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Raft/BlobRaftMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/aspirapb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	BlobRaftMessage(context.Context, *BlobRaftMessageRequest) (*BlobRaftMessageResponse, error)
	JoinCluster(context.Context, *RaftContext) (*Payload, error)
}

// UnimplementedRaftServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (*UnimplementedRaftServer) Heartbeat(req *Payload, srv Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (*UnimplementedRaftServer) RaftMessage(srv Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (*UnimplementedRaftServer) BlobRaftMessage(ctx context.Context, req *BlobRaftMessageRequest) (*BlobRaftMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlobRaftMessage not implemented")
}
func (*UnimplementedRaftServer) JoinCluster(ctx context.Context, req *RaftContext) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_BlobRaftMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobRaftMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).BlobRaftMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Raft/BlobRaftMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).BlobRaftMessage(ctx, req.(*BlobRaftMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BlobRaftMessage",
			Handler:    _Raft_BlobRaftMessage_Handler,
		},
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// AspiraGRPCClient is the client API for AspiraGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AspiraGRPCClient interface {
	StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (AspiraGRPC_StreamSnapshotClient, error)
}

type aspiraGRPCClient struct {
	cc *grpc.ClientConn
}

func NewAspiraGRPCClient(cc *grpc.ClientConn) AspiraGRPCClient {
	return &aspiraGRPCClient{cc}
}

func (c *aspiraGRPCClient) StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (AspiraGRPC_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AspiraGRPC_serviceDesc.Streams[0], "/aspirapb.AspiraGRPC/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &aspiraGRPCStreamSnapshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AspiraGRPC_StreamSnapshotClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type aspiraGRPCStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *aspiraGRPCStreamSnapshotClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AspiraGRPCServer is the server API for AspiraGRPC service.
type AspiraGRPCServer interface {
	StreamSnapshot(*RaftContext, AspiraGRPC_StreamSnapshotServer) error
}

// UnimplementedAspiraGRPCServer can be embedded to have forward compatible implementations.
type UnimplementedAspiraGRPCServer struct {
}

func (*UnimplementedAspiraGRPCServer) StreamSnapshot(req *RaftContext, srv AspiraGRPC_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}

func RegisterAspiraGRPCServer(s *grpc.Server, srv AspiraGRPCServer) {
	s.RegisterService(&_AspiraGRPC_serviceDesc, srv)
}

func _AspiraGRPC_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RaftContext)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AspiraGRPCServer).StreamSnapshot(m, &aspiraGRPCStreamSnapshotServer{stream})
}

type AspiraGRPC_StreamSnapshotServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type aspiraGRPCStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *aspiraGRPCStreamSnapshotServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

var _AspiraGRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.AspiraGRPC",
	HandlerType: (*AspiraGRPCServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _AspiraGRPC_StreamSnapshot_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// ZeroGRPCClient is the client API for ZeroGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZeroGRPCClient interface {
	WorkerHeartbeat(ctx context.Context, in *WorkerHeartbeatRequest, opts ...grpc.CallOption) (*WorkerHeartbeatResponse, error)
	AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error)
	ZeroStatus(ctx context.Context, in *ZeroStatusRequest, opts ...grpc.CallOption) (*ZeroStatusResponse, error)
}

type zeroGRPCClient struct {
	cc *grpc.ClientConn
}

func NewZeroGRPCClient(cc *grpc.ClientConn) ZeroGRPCClient {
	return &zeroGRPCClient{cc}
}

func (c *zeroGRPCClient) WorkerHeartbeat(ctx context.Context, in *WorkerHeartbeatRequest, opts ...grpc.CallOption) (*WorkerHeartbeatResponse, error) {
	out := new(WorkerHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.ZeroGRPC/WorkerHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroGRPCClient) AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error) {
	out := new(AllocIDResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.ZeroGRPC/AllocID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroGRPCClient) ZeroStatus(ctx context.Context, in *ZeroStatusRequest, opts ...grpc.CallOption) (*ZeroStatusResponse, error) {
	out := new(ZeroStatusResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.ZeroGRPC/ZeroStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroGRPCServer is the server API for ZeroGRPC service.
type ZeroGRPCServer interface {
	WorkerHeartbeat(context.Context, *WorkerHeartbeatRequest) (*WorkerHeartbeatResponse, error)
	AllocID(context.Context, *AllocIDRequest) (*AllocIDResponse, error)
	ZeroStatus(context.Context, *ZeroStatusRequest) (*ZeroStatusResponse, error)
}

// UnimplementedZeroGRPCServer can be embedded to have forward compatible implementations.
type UnimplementedZeroGRPCServer struct {
}

func (*UnimplementedZeroGRPCServer) WorkerHeartbeat(ctx context.Context, req *WorkerHeartbeatRequest) (*WorkerHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerHeartbeat not implemented")
}
func (*UnimplementedZeroGRPCServer) AllocID(ctx context.Context, req *AllocIDRequest) (*AllocIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocID not implemented")
}
func (*UnimplementedZeroGRPCServer) ZeroStatus(ctx context.Context, req *ZeroStatusRequest) (*ZeroStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZeroStatus not implemented")
}

func RegisterZeroGRPCServer(s *grpc.Server, srv ZeroGRPCServer) {
	s.RegisterService(&_ZeroGRPC_serviceDesc, srv)
}

func _ZeroGRPC_WorkerHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroGRPCServer).WorkerHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.ZeroGRPC/WorkerHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroGRPCServer).WorkerHeartbeat(ctx, req.(*WorkerHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZeroGRPC_AllocID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroGRPCServer).AllocID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.ZeroGRPC/AllocID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroGRPCServer).AllocID(ctx, req.(*AllocIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZeroGRPC_ZeroStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZeroStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroGRPCServer).ZeroStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.ZeroGRPC/ZeroStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroGRPCServer).ZeroStatus(ctx, req.(*ZeroStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZeroGRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.ZeroGRPC",
	HandlerType: (*ZeroGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkerHeartbeat",
			Handler:    _ZeroGRPC_WorkerHeartbeat_Handler,
		},
		{
			MethodName: "AllocID",
			Handler:    _ZeroGRPC_AllocID_Handler,
		},
		{
			MethodName: "ZeroStatus",
			Handler:    _ZeroGRPC_ZeroStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aspirapb.proto",
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MembershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAspirapb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SinceTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReadTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntryMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.EntryType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AspiraProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AspiraProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AspiraProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Offset != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Key != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x10
	}
	if m.ProposalType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ProposalType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlobRaftMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobRaftMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobRaftMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlobRaftMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobRaftMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobRaftMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkerHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rd != nil {
		{
			size, err := m.Rd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Progress) > 0 {
		for k := range m.Progress {
			v := m.Progress[k]
			baseI := i
			i = encodeVarintAspirapb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ZeroStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ZeroStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintAspirapb(dAtA []byte, offset int, v uint64) int {
	offset -= sovAspirapb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + 1 + len(v) + sovAspirapb(uint64(len(v)))
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.ReadTs != 0 {
		n += 1 + sovAspirapb(uint64(m.ReadTs))
	}
	if m.Done {
		n += 2
	}
	if m.SinceTs != 0 {
		n += 1 + sovAspirapb(uint64(m.SinceTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovAspirapb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.EntryType != 0 {
		n += 1 + sovAspirapb(uint64(m.EntryType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AspiraProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalType != 0 {
		n += 1 + sovAspirapb(uint64(m.ProposalType))
	}
	if m.Key != 0 {
		n += 1 + sovAspirapb(uint64(m.Key))
	}
	if m.Offset != 0 {
		n += 1 + sovAspirapb(uint64(m.Offset))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobRaftMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobRaftMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAspirapb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + 1 + sovAspirapb(uint64(v))
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAspirapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAspirapb(x uint64) (n int) {
	return sovAspirapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= EntryMeta_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AspiraProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AspiraProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AspiraProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalType", wireType)
			}
			m.ProposalType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalType |= AspiraProposal_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobRaftMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobRaftMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobRaftMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobRaftMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobRaftMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobRaftMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[uint64]WorkerHeartbeatRequest_ProgressType)
			}
			var mapkey uint64
			var mapvalue WorkerHeartbeatRequest_ProgressType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= WorkerHeartbeatRequest_ProgressType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &RaftContext{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAspirapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAspirapb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAspirapb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAspirapb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAspirapb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAspirapb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAspirapb = fmt.Errorf("proto: unexpected end of group")
)
